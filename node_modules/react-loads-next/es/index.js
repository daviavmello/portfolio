import { createContext, useMemo, createElement, useRef, useEffect, useCallback, useContext, useReducer, useState } from 'react';

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

////////////////////////////////////////////////////////
var invocationTimestamps = new Map(); ////////////////////////////////////////////////////////

var recordsCache = new Map();
var records = {
  clear: function clear(opts) {
    recordsCache.clear();

    if (opts && opts.cacheProvider) {
      opts.cacheProvider.clear();
    }

    return;
  },
  delete: function _delete(key, opts) {
    recordsCache.delete(key);

    if (opts && opts.cacheProvider) {
      opts.cacheProvider.delete(key);
    }

    return;
  },
  set: function set(key, valOrFn, opts) {
    var record = recordsCache.get(key);

    if (record && record.cacheTimeout) {
      clearTimeout(record.cacheTimeout);
    }

    var val = valOrFn;

    if (typeof val === 'function') {
      val = val(record || {});
    }

    var cacheTimeout;

    if (opts && opts.cacheTime) {
      cacheTimeout = setTimeout(function () {
        records.delete(key);
      }, opts.cacheTime);
    } // Set an updated timestamp on the cached record


    val = _objectSpread({}, val, {
      cacheTimeout: cacheTimeout,
      updated: new Date()
    });
    recordsCache.set(key, val);

    if (opts && opts.cacheProvider) {
      opts.cacheProvider.set(key, val);
    }

    return;
  },
  get: function get(key, opts) {
    // First, check to see if the record exists in the cache.
    var record = recordsCache.get(key);

    if (record) {
      return record;
    } // Otherwise, fallback to the cache provider.


    if (opts && opts.cacheProvider) {
      var value = opts.cacheProvider.get(key);

      if (value) {
        return value;
      }
    }

    return undefined;
  }
}; ////////////////////////////////////////////////////////

var promises = new Map();
var revalidators = new Map();
var suspenders = new Map();
var updaters = new Map();

var cache = /*#__PURE__*/Object.freeze({
  invocationTimestamps: invocationTimestamps,
  records: records,
  promises: promises,
  revalidators: revalidators,
  suspenders: suspenders,
  updaters: updaters
});

var CACHE_STRATEGIES = {
  CONTEXT_ONLY: 'context-only',
  CONTEXT_AND_VARIABLES: 'context-and-variables'
};
var LOAD_POLICIES = {
  CACHE_FIRST: 'cache-first',
  CACHE_AND_LOAD: 'cache-and-load',
  LOAD_ONLY: 'load-only',
  CACHE_ONLY: 'cache-only'
};
var STATES = {
  IDLE: 'idle',
  PENDING: 'pending',
  PENDING_SLOW: 'pending-slow',
  RESOLVED: 'resolved',
  REJECTED: 'rejected',
  RELOADING: 'reloading',
  RELOADING_SLOW: 'reloading-slow'
};

var defaultConfig = {
  cacheTime: 0,
  cacheStrategy: CACHE_STRATEGIES.CONTEXT_AND_VARIABLES,
  debounce: 0,
  debounceCache: true,
  dedupingInterval: 500,
  delay: 0,
  defer: false,
  loadPolicy: LOAD_POLICIES.CACHE_AND_LOAD,
  revalidateOnWindowFocus: false,
  revalidateTime: 300000,
  suspense: false,
  throwError: false,
  timeout: 5000
};
var Context = createContext(defaultConfig);
function Provider(_ref) {
  var children = _ref.children,
      config = _ref.config;
  var newConfig = useMemo(function () {
    return Object.assign(defaultConfig, config);
  }, [config]);
  return createElement(Context.Provider, {
    value: newConfig
  }, children);
}

function useDetectMounted() {
  var hasMounted = useRef(true);
  var hasRendered = useRef(false);
  useEffect(function () {
    hasRendered.current = true;
    return function cleanup() {
      hasMounted.current = false;
    };
  }, []);
  return [hasMounted, hasRendered];
}

var noop = function noop() {};

function useInterval(callback, delay) {
  var savedCallback = useRef(noop);
  useEffect(function () {
    savedCallback.current = callback;
  }, [callback]);
  useEffect(function () {
    var handler = function handler() {
      return savedCallback.current.apply(savedCallback, arguments);
    };

    if (typeof delay === 'number') {
      var id = setInterval(handler, delay);
      return function () {
        return clearInterval(id);
      };
    }

    return;
  }, [delay]);
}

function usePrevious(value) {
  var ref = useRef();
  useEffect(function () {
    ref.current = value;
  }, [value]);
  return ref.current;
}

function useTimeout() {
  var timeout = useRef(undefined);

  var _setTimeout = useCallback(function (fn, ms) {
    // @ts-ignore
    timeout.current = setTimeout(fn, ms);
  }, []);

  var _clearTimeout = useCallback(function () {
    return clearTimeout(timeout.current);
  }, []);

  useEffect(function () {
    return function cleanup() {
      if (timeout) {
        clearTimeout(timeout.current);
      }
    };
  }, []);
  return [_setTimeout, _clearTimeout];
}

function isDocumentVisible() {
  if (typeof document !== 'undefined' && typeof document.visibilityState !== 'undefined') {
    return document.visibilityState !== 'hidden';
  }

  return true;
}
function isOnline() {
  if (typeof navigator.onLine !== 'undefined') {
    return navigator.onLine;
  }

  return true;
}
function getCacheKey(_ref) {
  var context = _ref.context,
      variablesHash = _ref.variablesHash,
      cacheStrategy = _ref.cacheStrategy;
  var cacheKey = Array.isArray(context) ? context.join('.') : context;

  if (variablesHash && cacheStrategy === CACHE_STRATEGIES.CONTEXT_AND_VARIABLES) {
    cacheKey = "".concat(cacheKey, ".").concat(variablesHash);
  }

  return cacheKey;
}

function broadcastChanges(cacheKey, record) {
  var updaters$$1 = updaters.get(cacheKey);

  if (updaters$$1) {
    updaters$$1.forEach(function (updater) {
      return updater({
        record: record,
        shouldBroadcast: false
      });
    });
  }
}

var IDLE_RECORD = {
  error: undefined,
  response: undefined,
  state: STATES.IDLE
};
function useLoads(context, fn, localConfig) {
  var globalConfig = useContext(Context);

  var config = _objectSpread({}, globalConfig, localConfig || {});

  var cacheProvider = config.cacheProvider,
      cacheStrategy = config.cacheStrategy,
      cacheTime = config.cacheTime,
      debounce = config.debounce,
      debounceCache = config.debounceCache,
      dedupingInterval = config.dedupingInterval,
      dedupeManualLoad = config.dedupeManualLoad,
      delay = config.delay,
      _initialResponse = config.initialResponse,
      loadPolicy = config.loadPolicy,
      onReject = config.onReject,
      onResolve = config.onResolve,
      pollingInterval = config.pollingInterval,
      pollWhile = config.pollWhile,
      pollWhenHidden = config.pollWhenHidden,
      rejectRetryInterval = config.rejectRetryInterval,
      revalidateOnWindowFocus = config.revalidateOnWindowFocus,
      revalidateTime = config.revalidateTime,
      suspense = config.suspense,
      throwError = config.throwError,
      timeout = config.timeout,
      updateFn = config.update;
  var defer = config.defer;
  var variables = config.variables;

  if (typeof variables === 'function') {
    try {
      variables = variables();
      defer = config.defer;
    } catch (err) {
      defer = true;
    }
  }

  var variablesHash = useMemo(function () {
    return JSON.stringify(variables);
  }, [variables]);
  var cacheKey = getCacheKey({
    context: context,
    variablesHash: variablesHash,
    cacheStrategy: cacheStrategy
  });
  var loadCount = useRef(0);
  var debounceCount = useRef(0);
  var prevCacheKey = usePrevious(cacheKey);
  var isSameContext = !prevCacheKey || prevCacheKey === cacheKey;
  var prevVariablesHash = usePrevious(JSON.stringify(variables));
  var isSameVariables = variablesHash === prevVariablesHash;

  var _useDetectMounted = useDetectMounted(),
      _useDetectMounted2 = _slicedToArray(_useDetectMounted, 2),
      hasMounted = _useDetectMounted2[0],
      hasRendered = _useDetectMounted2[1];

  var _useTimeout = useTimeout(),
      _useTimeout2 = _slicedToArray(_useTimeout, 2),
      setDelayTimeout = _useTimeout2[0],
      clearDelayTimeout = _useTimeout2[1];

  var _useTimeout3 = useTimeout(),
      _useTimeout4 = _slicedToArray(_useTimeout3, 1),
      setErrorRetryTimeout = _useTimeout4[0];

  var _useTimeout5 = useTimeout(),
      _useTimeout6 = _slicedToArray(_useTimeout5, 2),
      setTimeoutTimeout = _useTimeout6[0],
      clearTimeoutTimeout = _useTimeout6[1];

  var cachedRecord = useMemo(function () {
    if (cacheKey && loadPolicy !== LOAD_POLICIES.LOAD_ONLY) {
      return records.get(cacheKey, {
        cacheProvider: cacheProvider
      });
    }

    return;
  }, [cacheProvider, cacheKey, loadPolicy]);
  var initialResponse = useMemo(function () {
    return _initialResponse;
  }, []); // eslint-disable-line

  var initialRecord = initialResponse ? {
    response: initialResponse,
    error: undefined,
    state: STATES.RESOLVED
  } : _objectSpread({}, IDLE_RECORD, {
    state: defer ? STATES.IDLE : STATES.PENDING
  });

  if (cachedRecord && !defer) {
    initialRecord = cachedRecord;
  }

  var reducer = useCallback(function (state, action) {
    switch (action.type) {
      case STATES.IDLE:
        return IDLE_RECORD;

      case STATES.PENDING:
        return _objectSpread({}, state, {
          state: STATES.PENDING
        });

      case STATES.PENDING_SLOW:
        return _objectSpread({}, state, {
          state: STATES.PENDING_SLOW
        });

      case STATES.RESOLVED:
        return {
          isCached: action.isCached,
          error: undefined,
          response: action.response,
          state: STATES.RESOLVED
        };

      case STATES.REJECTED:
        return {
          isCached: action.isCached,
          error: action.error,
          response: undefined,
          state: STATES.REJECTED
        };

      case STATES.RELOADING:
        return _objectSpread({}, state, {
          state: STATES.RELOADING
        });

      case STATES.RELOADING_SLOW:
        return _objectSpread({}, state, {
          state: STATES.RELOADING_SLOW
        });

      default:
        return state;
    }
  }, []);

  var _React$useReducer = useReducer(reducer, initialRecord),
      _React$useReducer2 = _slicedToArray(_React$useReducer, 2),
      record = _React$useReducer2[0],
      dispatch = _React$useReducer2[1];

  var handleLoading = useCallback(function (_ref) {
    var isReloading = _ref.isReloading,
        isSlow = _ref.isSlow,
        promise = _ref.promise;
    var reloadingState = isSlow ? STATES.RELOADING_SLOW : STATES.RELOADING;
    var pendingState = isSlow ? STATES.PENDING_SLOW : STATES.PENDING;
    dispatch({
      type: isReloading ? reloadingState : pendingState
    });

    if (cacheKey) {
      records.set(cacheKey, function (record) {
        return _objectSpread({}, record, {
          state: isReloading ? STATES.RELOADING : STATES.PENDING
        });
      }, {
        cacheTime: cacheTime,
        cacheProvider: cacheProvider
      });

      if (!isReloading) {
        promises.set(cacheKey, promise);
      }
    }
  }, [cacheProvider, cacheTime, cacheKey]);
  var handleData = useCallback(function (_ref2) {
    var count = _ref2.count,
        record = _ref2.record,
        shouldBroadcast = _ref2.shouldBroadcast;

    if (hasMounted.current && (!count || count === loadCount.current)) {
      // @ts-ignore
      clearDelayTimeout(); // @ts-ignore

      clearTimeoutTimeout();
      dispatch(_objectSpread({
        type: record.state,
        isCached: Boolean(cacheKey)
      }, record));

      if (cacheKey) {
        records.set(cacheKey, record, {
          cacheProvider: cacheProvider,
          cacheTime: cacheTime
        });
        var isSuspended = suspenders.get(cacheKey);
        suspenders.set(cacheKey, typeof isSuspended === 'undefined');
        promises.delete(cacheKey);

        if (shouldBroadcast) {
          broadcastChanges(cacheKey, record);
        }
      }
    }
  }, [cacheProvider, cacheTime, clearDelayTimeout, clearTimeoutTimeout, cacheKey, hasMounted]);
  var handleOptimisticData = useCallback(function (_ref3, state, count) {
    var data = _ref3.data,
        contextOrCallback = _ref3.contextOrCallback,
        callback = _ref3.callback;
    var newData = data;
    var optimisticCacheKey = cacheKey;

    if (_typeof(contextOrCallback) === 'object') {
      var _variablesHash = JSON.stringify(contextOrCallback.variables);

      optimisticCacheKey = getCacheKey({
        context: contextOrCallback.context,
        variablesHash: _variablesHash,
        cacheStrategy: cacheStrategy
      });
    }

    if (typeof data === 'function') {
      var cachedValue = IDLE_RECORD;

      if (optimisticCacheKey) {
        cachedValue = records.get(optimisticCacheKey, {
          cacheProvider: cacheProvider
        }) || IDLE_RECORD;
      }

      newData = data(state === STATES.RESOLVED ? cachedValue.response : cachedValue.error);
    }

    var newRecord = {
      error: state === STATES.REJECTED ? newData : undefined,
      response: state === STATES.RESOLVED ? newData : undefined,
      state: state
    };

    if (!optimisticCacheKey || cacheKey === optimisticCacheKey) {
      handleData({
        count: count,
        record: newRecord,
        shouldBroadcast: true
      });
    } else {
      records.set(optimisticCacheKey, newRecord, {
        cacheProvider: cacheProvider,
        cacheTime: cacheTime
      });
    }

    var newCallback = typeof contextOrCallback === 'function' ? contextOrCallback : callback;
    newCallback && newCallback(newData);
  }, [cacheStrategy, cacheKey, cacheProvider, handleData, cacheTime]);
  var load = useCallback(function () {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return function () {
      for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
        _args[_key] = arguments[_key];
      }

      var _opts$setInvocationTi = opts.setInvocationTimestamp,
          setInvocationTimestamp = _opts$setInvocationTi === void 0 ? true : _opts$setInvocationTi;

      if (!opts.isManualInvoke && variables && isSameVariables) {
        return;
      } // Build cacheKey based of these args?


      var args = _args.filter(function (arg) {
        return arg.constructor.name !== 'Class';
      });

      if (variables && (!args || args.length === 0)) {
        args = variables;
      }

      if (context && debounce > 0) {
        var now = new Date().getTime();

        if (setInvocationTimestamp) {
          invocationTimestamps.set(context, now);
          invocationTimestamps.set('latest', now);
        }

        var latestInvocationTimestamp = invocationTimestamps.get(context || 'latest');

        if (latestInvocationTimestamp) {
          if (Math.abs(now - latestInvocationTimestamp) < debounce) {
            debounceCount.current = debounceCount.current + 1;
            setTimeout(function () {
              return load(_objectSpread({
                count: debounceCount.current,
                setInvocationTimestamp: false
              }, opts)).apply(void 0, _args);
            }, debounce);
            return;
          }

          if (debounceCount.current !== (opts.count || 0)) {
            return;
          }
        }

        debounceCount.current = 0;
      }

      var cachedRecord;

      if (cacheKey) {
        cachedRecord = records.get(cacheKey, {
          cacheProvider: cacheProvider
        });
      }

      if (cachedRecord) {
        var isDuplicate = // @ts-ignore
        Math.abs(new Date() - cachedRecord.updated) < dedupingInterval && (!opts.isManualInvoke || dedupeManualLoad);
        if (isDuplicate) return;
      }

      loadCount.current = loadCount.current + 1;
      var count = loadCount.current;

      if (cacheKey) {
        var isSuspended = suspenders.get(cacheKey);

        if (suspense && isSuspended) {
          suspenders.set(cacheKey, false);
          return;
        }
      }

      if (cacheKey && loadPolicy !== LOAD_POLICIES.LOAD_ONLY) {
        if (!defer && cachedRecord) {
          dispatch(_objectSpread({
            type: cachedRecord.state,
            isCached: true
          }, cachedRecord));

          if (cachedRecord.state === STATES.RESOLVED || cachedRecord.state === STATES.REJECTED) {
            // @ts-ignore
            var isStale = Math.abs(new Date() - cachedRecord.updated) >= revalidateTime;
            var isCachedWithCacheFirst = !isStale && !opts.isManualInvoke && loadPolicy === LOAD_POLICIES.CACHE_FIRST;
            if (isCachedWithCacheFirst) return;
          }
        }
      }

      var loadFn = opts.fn ? opts.fn : fn;
      var promiseOrFn = loadFn.apply(void 0, _toConsumableArray(args));
      var promise = promiseOrFn;

      if (typeof promiseOrFn === 'function') {
        promise = promiseOrFn({
          cachedRecord: cachedRecord,
          setResponse: function setResponse(data, contextOrCallback, callback) {
            return handleOptimisticData({
              data: data,
              contextOrCallback: contextOrCallback,
              callback: callback
            }, STATES.RESOLVED, count);
          },
          setError: function setError(data, contextOrCallback, callback) {
            return handleOptimisticData({
              data: data,
              contextOrCallback: contextOrCallback,
              callback: callback
            }, STATES.REJECTED, count);
          }
        });
      }

      var isReloading = context && isSameContext && (count > 1 || cachedRecord && !defer || initialResponse) || debounce > 0 && debounceCache;

      if (delay > 0) {
        setDelayTimeout(function () {
          return handleLoading({
            isReloading: isReloading,
            promise: promise
          });
        }, delay);
      } else {
        handleLoading({
          isReloading: isReloading,
          promise: promise
        });
      }

      if (timeout > 0) {
        setTimeoutTimeout(function () {
          return handleLoading({
            isReloading: isReloading,
            isSlow: true,
            promise: promise
          });
        }, timeout);
      }

      if (typeof promise === 'function') return;
      return promise.then(function (response) {
        handleData({
          count: count,
          record: {
            error: undefined,
            response: response,
            state: STATES.RESOLVED
          },
          shouldBroadcast: true
        });
        onResolve && onResolve(response);
        return response;
      }).catch(function (error) {
        handleData({
          count: count,
          record: {
            response: undefined,
            error: error,
            state: STATES.REJECTED
          },
          shouldBroadcast: false
        });
        onReject && onReject(error);

        if (rejectRetryInterval) {
          var _count = Math.min(loadCount.current || 0, 8);

          var _timeout = typeof rejectRetryInterval === 'function' ? rejectRetryInterval(_count) : ~~((Math.random() + 0.5) * (1 << _count)) * rejectRetryInterval;

          setErrorRetryTimeout(function () {
            return load()(args);
          }, _timeout);
        }

        if (throwError && !suspense) {
          throw error;
        }
      });
    };
  }, [variablesHash, isSameVariables, context, debounce, cacheKey, loadPolicy, fn, isSameContext, defer, initialResponse, debounceCache, delay, timeout, cacheProvider, dedupingInterval, dedupeManualLoad, suspense, revalidateTime, handleOptimisticData, setDelayTimeout, handleLoading, setTimeoutTimeout, handleData, onResolve, onReject, rejectRetryInterval, throwError, setErrorRetryTimeout]);
  var update = useMemo(function () {
    if (!updateFn) return;

    if (Array.isArray(updateFn)) {
      return updateFn.map(function (fn) {
        return load({
          fn: fn,
          isManualInvoke: true
        });
      });
    }

    return load({
      fn: updateFn,
      isManualInvoke: true
    });
  }, [load, updateFn]);
  var reset = useCallback(function () {
    dispatch({
      type: STATES.IDLE
    });
  }, []);
  useEffect(function () {
    if (!cachedRecord && cacheKey && !initialResponse && !debounceCache) {
      reset();
    }
  }, [cachedRecord, cacheKey, initialResponse, reset, debounceCache]);
  useEffect(function () {
    if (cachedRecord && !defer && loadPolicy !== LOAD_POLICIES.LOAD_ONLY) {
      dispatch(_objectSpread({
        type: cachedRecord.state,
        isCached: true
      }, cachedRecord));
    }
  }, [cachedRecord, loadPolicy, dispatch, defer]);
  useEffect(function () {
    if (defer || suspense && !hasRendered.current && !cachedRecord || loadPolicy === LOAD_POLICIES.CACHE_ONLY) return;
    load()();
  }, [defer, cacheKey, suspense, hasRendered, cachedRecord, load, loadPolicy]);
  useEffect(function () {
    if (defer) return;
    var updaters$$1 = updaters.get(cacheKey);

    if (updaters$$1) {
      var newUpdaters = [].concat(_toConsumableArray(updaters$$1), [handleData]);
      updaters.set(cacheKey, newUpdaters);
    } else {
      updaters.set(cacheKey, [handleData]);
    }

    return function cleanup() {
      var updaters$$1 = updaters.get(cacheKey);
      var newUpdaters = updaters$$1.filter(function (updater) {
        return updater !== handleData;
      });
      updaters.set(cacheKey, newUpdaters);
    };
  }, [cacheKey, defer, handleData]);
  useEffect(function () {
    if (!revalidateOnWindowFocus || defer) return;
    var revalidate = load();
    revalidators.set(cacheKey, revalidate);
    return function cleanup() {
      revalidators.delete(cacheKey);
    };
  }, [cacheKey, defer, handleData, load, revalidateOnWindowFocus]);
  var shouldPoll = !defer;

  if (shouldPoll && pollWhile) {
    if (typeof pollWhile === 'function') {
      shouldPoll = pollWhile(record);
    } else {
      shouldPoll = pollWhile;
    }
  }

  useInterval(function () {
    if (!isDocumentVisible() && !pollWhenHidden) return;
    load({
      isManualInvoke: true
    })();
  }, shouldPoll ? pollingInterval : undefined);
  var states = useMemo(function () {
    return {
      isIdle: record.state === STATES.IDLE && Boolean(!record.response),
      isPending: record.state === STATES.PENDING || record.state === STATES.PENDING_SLOW,
      isPendingSlow: record.state === STATES.PENDING_SLOW,
      isResolved: record.state === STATES.RESOLVED || Boolean(record.response),
      isRejected: record.state === STATES.REJECTED,
      isReloading: record.state === STATES.RELOADING || record.state === STATES.RELOADING_SLOW,
      isReloadingSlow: record.state === STATES.RELOADING_SLOW
    };
  }, [record.response, record.state]);

  if (suspense && !defer) {
    if (cacheKey) {
      var _record = records.get(cacheKey);

      var promise = promises.get(cacheKey);

      if (_record && promise) {
        throw promise;
      }

      if (!_record) {
        load()();
      }
    }

    if (states.isRejected) {
      throw record.error;
    }
  }

  return useMemo(function () {
    return _objectSpread({
      load: load({
        isManualInvoke: true
      }),
      update: update,
      reset: reset,
      response: record.response,
      error: record.error,
      state: record.state
    }, states, {
      isCached: Boolean(record.isCached)
    });
  }, [load, update, reset, record.response, record.error, record.state, record.isCached, states]);
}
var eventsBinded = false;

if (typeof window !== 'undefined' && window.addEventListener && !eventsBinded) {
  var revalidate = function revalidate() {
    if (!isDocumentVisible() || !isOnline()) return;
    revalidators.forEach(function (revalidator) {
      return revalidator && revalidator();
    });
  };

  window.addEventListener('visibilitychange', revalidate, false);
  window.addEventListener('focus', revalidate, false);
  eventsBinded = true;
}

function preload(context, promiseOrFn, localConfig) {
  var config = _objectSpread({}, defaultConfig, localConfig || {});

  var cacheTime = config.cacheTime,
      cacheProvider = config.cacheProvider,
      cacheStrategy = config.cacheStrategy,
      dedupingInterval = config.dedupingInterval,
      loadPolicy = config.loadPolicy,
      onResolve = config.onResolve,
      onReject = config.onReject,
      rejectRetryInterval = config.rejectRetryInterval,
      revalidateTime = config.revalidateTime,
      suspense = config.suspense,
      throwError = config.throwError,
      variables = config.variables;

  function setData(_ref) {
    var cacheKey = _ref.cacheKey,
        record = _ref.record;
    var config = {
      cacheProvider: cacheProvider,
      cacheTime: cacheTime
    };
    records.set(cacheKey, record, config);
  }

  var count = 0;

  function load() {
    count = count + 1;
    var args = variables || [];

    if (typeof args === 'function') {
      try {
        args = args() || [];
      } catch (err) {
        throw new Error('TODO');
      }
    }

    var variablesHash = JSON.stringify(args);
    var cacheKey = getCacheKey({
      context: context,
      variablesHash: variablesHash,
      cacheStrategy: cacheStrategy
    });
    if (!cacheKey) throw new Error('preload() must have a context');
    var cachedRecord;

    if (loadPolicy !== LOAD_POLICIES.LOAD_ONLY) {
      cachedRecord = records.get(cacheKey);
    }

    if (cachedRecord) {
      // @ts-ignore
      var isStale = Math.abs(new Date() - cachedRecord.updated) >= revalidateTime;
      var isDuplicate = // @ts-ignore
      Math.abs(new Date() - cachedRecord.updated) < dedupingInterval;
      var isCachedWithCacheFirst = !isStale && loadPolicy === LOAD_POLICIES.CACHE_FIRST;
      if (isDuplicate || isCachedWithCacheFirst) return;
    }

    var promise = promiseOrFn.apply(void 0, _toConsumableArray(args));

    if (typeof promise === 'function') {
      promise = promise({
        cachedRecord: cachedRecord
      });
    }

    var isReloading = Boolean(cachedRecord);
    records.set(cacheKey, function (record) {
      return _objectSpread({}, record, {
        state: cachedRecord ? STATES.RELOADING : STATES.PENDING
      });
    }, {
      cacheTime: cacheTime,
      cacheProvider: cacheProvider
    });

    if (!isReloading) {
      promises.set(cacheKey, promise);
    }

    if (typeof promise === 'function') return;
    promise.then(function (response) {
      var record = {
        error: undefined,
        response: response,
        state: STATES.RESOLVED
      };
      setData({
        cacheKey: cacheKey,
        record: record
      });
      onResolve && onResolve(response);
    }).catch(function (error) {
      var record = {
        response: undefined,
        error: error,
        state: STATES.REJECTED
      };
      setData({
        cacheKey: cacheKey,
        record: record
      });
      onReject && onReject(error);

      if (rejectRetryInterval) {
        var attemptCount = Math.min(count || 0, 8);
        var timeout = typeof rejectRetryInterval === 'function' ? rejectRetryInterval(attemptCount) : ~~((Math.random() + 0.5) * (1 << attemptCount)) * rejectRetryInterval;
        setTimeout(function () {
          return load();
        }, timeout);
      }

      if (throwError && !suspense) {
        throw error;
      }
    }).finally(function () {
      promises.delete(cacheKey);
    });
  }

  load();
  return {
    useLoads: function useLoads$$1() {
      var loadsConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return useLoads(context, promiseOrFn, _objectSpread({}, config, loadsConfig, {
        loadPolicy: LOAD_POLICIES.CACHE_ONLY
      }));
    }
  };
}

function useDeferredLoads(contextOrFn, fnOrConfig, maybeConfig) {
  var context = contextOrFn;
  var config = maybeConfig;
  var fn = fnOrConfig;

  if (typeof contextOrFn === 'function') {
    context = null;
    fn = contextOrFn;
  }

  if (_typeof(fnOrConfig) === 'object') {
    config = fnOrConfig;
  }

  return useLoads(context, fn, _objectSpread({}, config, {
    defer: true
  }));
}

function createLoadsHooks(opts) {
  return Object.entries(opts).reduce(function (currentLoaders, _ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        loadKey = _ref2[0],
        val = _ref2[1];

    if (loadKey[0] === '_' || typeof val === 'string') return currentLoaders;
    var loader = val;
    var config = {};

    if (Array.isArray(val)) {
      loader = val[0];
      config = val[1] || {};
    }

    if (loadKey === 'fn') {
      return _objectSpread({}, currentLoaders, {
        preload: function preload$$1(loadsConfig) {
          return preload(opts.context, loader, _objectSpread({}, config, loadsConfig));
        },
        useLoads: function useLoads$$1(loadsConfig) {
          return useLoads(opts.context, loader, _objectSpread({}, config, loadsConfig));
        },
        useDeferredLoads: function useDeferredLoads$$1(loadsConfig) {
          return useDeferredLoads(opts.context, loader, _objectSpread({}, config, loadsConfig));
        }
      });
    }

    return _objectSpread({}, currentLoaders, _defineProperty({}, loadKey, {
      preload: function preload$$1(loadsConfig) {
        return preload(opts.context, loader, _objectSpread({}, config, loadsConfig));
      },
      useLoads: function useLoads$$1(loadsConfig) {
        return useLoads(opts.context, loader, _objectSpread({}, config, loadsConfig));
      },
      useDeferredLoads: function useDeferredLoads$$1(loadsConfig) {
        return useDeferredLoads(opts.context, loader, _objectSpread({}, config, loadsConfig));
      }
    }));
  }, {});
}

function createResource(opts) {
  return _objectSpread({}, createLoadsHooks(opts));
}

var Loads = function Loads(_ref) {
  var children = _ref.children,
      context = _ref.context,
      fn = _ref.fn,
      inputs = _ref.inputs,
      config = _objectWithoutProperties(_ref, ["children", "context", "fn", "inputs"]);

  var record = useLoads(context, fn, config);
  return children(record);
};
Loads.defaultProps = {
  inputs: []
};

function useCache(context) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      variables = _ref.variables;

  var cacheKey = Array.isArray(context) ? context.join('.') : context;
  var variablesHash = useMemo(function () {
    return JSON.stringify(variables);
  }, [variables]);

  if (variablesHash) {
    cacheKey = "".concat(cacheKey, ".").concat(variablesHash);
  }

  var _React$useState = useState(function () {
    return records.get(cacheKey);
  }),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      record = _React$useState2[0],
      setRecord = _React$useState2[1];

  var handleData = useCallback(function (_ref2) {
    var record = _ref2.record;
    setRecord(record);
  }, []);
  useEffect(function () {
    var updaters$$1 = updaters.get(cacheKey);

    if (updaters$$1) {
      var newUpdaters = [].concat(_toConsumableArray(updaters$$1), [handleData]);
      updaters.set(cacheKey, newUpdaters);
    } else {
      updaters.set(cacheKey, [handleData]);
    }
  });
  return record;
}

function useGetStates() {
  for (var _len = arguments.length, records = new Array(_len), _key = 0; _key < _len; _key++) {
    records[_key] = arguments[_key];
  }

  var isIdle = useMemo(function () {
    return !records.some(function (record) {
      return !record.isIdle;
    });
  }, [records]);
  var isPending = useMemo(function () {
    return records.some(function (record) {
      return record.isPending;
    });
  }, [records]);
  var isPendingSlow = useMemo(function () {
    return records.some(function (record) {
      return record.isPendingSlow;
    });
  }, [records]);
  var isResolved = useMemo(function () {
    return !records.some(function (record) {
      return !record.isResolved && !record.isIdle;
    });
  }, [records]);
  var isRejected = useMemo(function () {
    return records.some(function (record) {
      return record.isRejected;
    });
  }, [records]);
  var isReloading = useMemo(function () {
    return records.some(function (record) {
      return record.isReloading;
    });
  }, [records]);
  var isReloadingSlow = useMemo(function () {
    return records.some(function (record) {
      return record.isReloadingSlow;
    });
  }, [records]);
  return useMemo(function () {
    return {
      isIdle: isIdle,
      isPending: isPending,
      isPendingSlow: isPendingSlow,
      isResolved: isResolved,
      isRejected: isRejected,
      isReloading: isReloading,
      isReloadingSlow: isReloadingSlow
    };
  }, [isIdle, isPending, isPendingSlow, isRejected, isReloading, isReloadingSlow, isResolved]);
}

export { cache, invocationTimestamps, records, promises, revalidators, suspenders, updaters, createResource, Loads, defaultConfig, Context, Provider, preload, useCache, useLoads, useDeferredLoads, useGetStates };
