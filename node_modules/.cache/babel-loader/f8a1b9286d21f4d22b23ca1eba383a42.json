{"ast":null,"code":"import { a as _objectSpread2, _ as _objectWithoutPropertiesLoose } from '../_rollupPluginBabelHelpers-1f0bf8c2.js';\nimport { createComponent } from 'reakit-system/createComponent';\nimport { createHook } from 'reakit-system/createHook';\nimport 'reakit-utils/shallowEqual';\nimport { useRef, useEffect, useCallback, useReducer } from 'react';\nimport { useForkRef } from 'reakit-utils/useForkRef';\nimport 'reakit-utils/isButton';\nimport { warning, useWarning } from 'reakit-warning';\nimport { useLiveRef } from 'reakit-utils/useLiveRef';\nimport { isSelfTarget } from 'reakit-utils/isSelfTarget';\nimport 'reakit-utils/useIsomorphicEffect';\nimport 'reakit-utils/hasFocusWithin';\nimport 'reakit-utils/isPortalEvent';\nimport 'reakit-utils/getActiveElement';\nimport { canUseDOM } from 'reakit-utils/canUseDOM';\nimport 'reakit-utils/tabbable';\nimport { useRole } from '../Role/Role.js';\nimport { useTabbable } from '../Tabbable/Tabbable.js';\nimport { useCreateElement } from 'reakit-system/useCreateElement';\nimport { getDocument } from 'reakit-utils/getDocument';\nimport { fireBlurEvent } from 'reakit-utils/fireBlurEvent';\nimport { fireKeyboardEvent } from 'reakit-utils/fireKeyboardEvent';\nimport { getNextActiveElementOnBlur } from 'reakit-utils/getNextActiveElementOnBlur';\nimport { f as flatten, r as reverse, g as groupItems } from '../reverse-30eaa122.js';\nimport { g as getCurrentId, f as findFirstEnabledItem } from '../getCurrentId-5aa9849e.js';\nimport { f as findEnabledItemById } from '../findEnabledItemById-8ddca752.js';\nimport { C as COMPOSITE_KEYS } from '../__keys-6742f591.js';\nimport { u as userFocus } from '../userFocus-e16425e3.js';\nvar isIE11 = canUseDOM && \"msCrypto\" in window;\n\nfunction canProxyKeyboardEvent(event) {\n  if (!isSelfTarget(event)) return false;\n  if (event.metaKey) return false;\n  if (event.key === \"Tab\") return false;\n  return true;\n}\n\nfunction useKeyboardEventProxy(virtual, currentItem, htmlEventHandler) {\n  var eventHandlerRef = useLiveRef(htmlEventHandler);\n  return useCallback(function (event) {\n    var _eventHandlerRef$curr;\n\n    (_eventHandlerRef$curr = eventHandlerRef.current) === null || _eventHandlerRef$curr === void 0 ? void 0 : _eventHandlerRef$curr.call(eventHandlerRef, event);\n    if (event.defaultPrevented) return;\n\n    if (virtual && canProxyKeyboardEvent(event)) {\n      var currentElement = currentItem === null || currentItem === void 0 ? void 0 : currentItem.ref.current;\n\n      if (currentElement) {\n        if (!fireKeyboardEvent(currentElement, event.type, event)) {\n          event.preventDefault();\n        } // The event will be triggered on the composite item and then\n        // propagated up to this composite element again, so we can pretend\n        // that it wasn't called on this component in the first place.\n\n\n        if (event.currentTarget.contains(currentElement)) {\n          event.stopPropagation();\n        }\n      }\n    }\n  }, [virtual, currentItem]);\n} // istanbul ignore next\n\n\nfunction useActiveElementRef(elementRef) {\n  var activeElementRef = useRef(null);\n  useEffect(function () {\n    var document = getDocument(elementRef.current);\n\n    var onFocus = function onFocus(event) {\n      var target = event.target;\n      activeElementRef.current = target;\n    };\n\n    document.addEventListener(\"focus\", onFocus, true);\n    return function () {\n      document.removeEventListener(\"focus\", onFocus, true);\n    };\n  }, []);\n  return activeElementRef;\n}\n\nfunction findFirstEnabledItemInTheLastRow(items) {\n  return findFirstEnabledItem(flatten(reverse(groupItems(items))));\n}\n\nfunction isItem(items, element) {\n  return items === null || items === void 0 ? void 0 : items.some(function (item) {\n    return !!element && item.ref.current === element;\n  });\n}\n\nfunction useScheduleUserFocus(currentItem) {\n  var currentItemRef = useLiveRef(currentItem);\n\n  var _React$useReducer = useReducer(function (n) {\n    return n + 1;\n  }, 0),\n      scheduled = _React$useReducer[0],\n      schedule = _React$useReducer[1];\n\n  useEffect(function () {\n    var _currentItemRef$curre;\n\n    var currentElement = (_currentItemRef$curre = currentItemRef.current) === null || _currentItemRef$curre === void 0 ? void 0 : _currentItemRef$curre.ref.current;\n\n    if (scheduled && currentElement) {\n      userFocus(currentElement);\n    }\n  }, [scheduled]);\n  return schedule;\n}\n\nvar useComposite = createHook({\n  name: \"Composite\",\n  compose: [useTabbable],\n  keys: COMPOSITE_KEYS,\n  useOptions: function useOptions(options) {\n    return _objectSpread2(_objectSpread2({}, options), {}, {\n      currentId: getCurrentId(options)\n    });\n  },\n  useProps: function useProps(options, _ref) {\n    var htmlRef = _ref.ref,\n        htmlOnFocusCapture = _ref.onFocusCapture,\n        htmlOnFocus = _ref.onFocus,\n        htmlOnBlurCapture = _ref.onBlurCapture,\n        htmlOnKeyDown = _ref.onKeyDown,\n        htmlOnKeyDownCapture = _ref.onKeyDownCapture,\n        htmlOnKeyUpCapture = _ref.onKeyUpCapture,\n        htmlProps = _objectWithoutPropertiesLoose(_ref, [\"ref\", \"onFocusCapture\", \"onFocus\", \"onBlurCapture\", \"onKeyDown\", \"onKeyDownCapture\", \"onKeyUpCapture\"]);\n\n    var ref = useRef(null);\n    var currentItem = findEnabledItemById(options.items, options.currentId);\n    var previousElementRef = useRef(null);\n    var onFocusCaptureRef = useLiveRef(htmlOnFocusCapture);\n    var onFocusRef = useLiveRef(htmlOnFocus);\n    var onBlurCaptureRef = useLiveRef(htmlOnBlurCapture);\n    var onKeyDownRef = useLiveRef(htmlOnKeyDown);\n    var scheduleUserFocus = useScheduleUserFocus(currentItem); // IE 11 doesn't support event.relatedTarget, so we use the active element\n    // ref instead.\n\n    var activeElementRef = isIE11 ? useActiveElementRef(ref) : undefined;\n    useEffect(function () {\n      var element = ref.current;\n\n      if (options.unstable_moves && !currentItem) {\n        process.env.NODE_ENV !== \"production\" ? warning(!element, \"Can't focus composite component because `ref` wasn't passed to component.\", \"See https://reakit.io/docs/composite\") : void 0; // If composite.move(null) has been called, the composite container\n        // will receive focus.\n\n        element === null || element === void 0 ? void 0 : element.focus();\n      }\n    }, [options.unstable_moves, currentItem]);\n    var onKeyDownCapture = useKeyboardEventProxy(options.unstable_virtual, currentItem, htmlOnKeyDownCapture);\n    var onKeyUpCapture = useKeyboardEventProxy(options.unstable_virtual, currentItem, htmlOnKeyUpCapture);\n    var onFocusCapture = useCallback(function (event) {\n      var _onFocusCaptureRef$cu;\n\n      (_onFocusCaptureRef$cu = onFocusCaptureRef.current) === null || _onFocusCaptureRef$cu === void 0 ? void 0 : _onFocusCaptureRef$cu.call(onFocusCaptureRef, event);\n      if (event.defaultPrevented) return;\n      if (!options.unstable_virtual) return; // IE11 doesn't support event.relatedTarget, so we use the active\n      // element ref instead.\n\n      var previousActiveElement = (activeElementRef === null || activeElementRef === void 0 ? void 0 : activeElementRef.current) || event.relatedTarget;\n      var previousActiveElementWasItem = isItem(options.items, previousActiveElement);\n\n      if (isSelfTarget(event) && previousActiveElementWasItem) {\n        // Composite has been focused as a result of an item receiving focus.\n        // The composite item will move focus back to the composite\n        // container. In this case, we don't want to propagate this\n        // additional event nor call the onFocus handler passed to\n        // <Composite onFocus={...} />.\n        event.stopPropagation();\n      }\n    }, [options.unstable_virtual, options.items]);\n    var onFocus = useCallback(function (event) {\n      var _onFocusRef$current;\n\n      (_onFocusRef$current = onFocusRef.current) === null || _onFocusRef$current === void 0 ? void 0 : _onFocusRef$current.call(onFocusRef, event);\n      if (event.defaultPrevented) return;\n\n      if (options.unstable_virtual) {\n        if (isSelfTarget(event)) {\n          // This means that the composite element has been focused while the\n          // composite item has not. For example, by clicking on the\n          // composite element without touching any item, or by tabbing into\n          // the composite element. In this case, we want to trigger focus on\n          // the item, just like it would happen with roving tabindex.\n          // When it receives focus, the composite item will put focus back\n          // on the composite element, in which case hasItemWithFocus will be\n          // true.\n          scheduleUserFocus();\n        }\n      } else if (isSelfTarget(event)) {\n        var _options$setCurrentId; // When the roving tabindex composite gets intentionally focused (for\n        // example, by clicking directly on it, and not on an item), we make\n        // sure to set the current id to null (which means the composite\n        // itself is focused).\n\n\n        (_options$setCurrentId = options.setCurrentId) === null || _options$setCurrentId === void 0 ? void 0 : _options$setCurrentId.call(options, null);\n      }\n    }, [options.unstable_virtual, options.setCurrentId]);\n    var onBlurCapture = useCallback(function (event) {\n      var _onBlurCaptureRef$cur;\n\n      (_onBlurCaptureRef$cur = onBlurCaptureRef.current) === null || _onBlurCaptureRef$cur === void 0 ? void 0 : _onBlurCaptureRef$cur.call(onBlurCaptureRef, event);\n      if (event.defaultPrevented) return;\n      if (!options.unstable_virtual) return; // When virtual is set to true, we move focus from the composite\n      // container (this component) to the composite item that is being\n      // selected. Then we move focus back to the composite container. This\n      // is so we can provide the same API as the roving tabindex method,\n      // which means people can attach onFocus/onBlur handlers on the\n      // CompositeItem component regardless of whether it's virtual or not.\n      // This sequence of blurring and focusing items and composite may be\n      // confusing, so we ignore intermediate focus and blurs by stopping its\n      // propagation and not calling the passed onBlur handler (htmlOnBlur).\n\n      var currentElement = (currentItem === null || currentItem === void 0 ? void 0 : currentItem.ref.current) || null;\n      var nextActiveElement = getNextActiveElementOnBlur(event);\n      var nextActiveElementIsItem = isItem(options.items, nextActiveElement);\n\n      if (isSelfTarget(event) && nextActiveElementIsItem) {\n        // This is an intermediate blur event: blurring the composite\n        // container to focus an item (nextActiveElement).\n        if (nextActiveElement === currentElement) {\n          // The next active element will be the same as the current item in\n          // the state in two scenarios:\n          //   - Moving focus with keyboard: the state is updated before the\n          // blur event is triggered, so here the current item is already\n          // pointing to the next active element.\n          //   - Clicking on the current active item with a pointer: this\n          // will trigger blur on the composite element and then the next\n          // active element will be the same as the current item. Clicking on\n          // an item other than the current one doesn't end up here as the\n          // currentItem state will be updated only after it.\n          if (previousElementRef.current && previousElementRef.current !== nextActiveElement) {\n            // If there's a previous active item and it's not a click action,\n            // then we fire a blur event on it so it will work just like if\n            // it had DOM focus before (like when using roving tabindex).\n            fireBlurEvent(previousElementRef.current, event);\n          }\n\n          previousElementRef.current = currentElement;\n        } else if (currentElement) {\n          // This will be true when the next active element is not the\n          // current element, but there's a current item. This will only\n          // happen when clicking with a pointer on a different item, when\n          // there's already an item selected, in which case currentElement\n          // is the item that is getting blurred, and nextActiveElement is\n          // the item that is being clicked.\n          fireBlurEvent(currentElement, event);\n          previousElementRef.current = nextActiveElement;\n        } // We want to ignore intermediate blur events, so we stop its\n        // propagation and return early so onFocus will not be called.\n\n\n        event.stopPropagation();\n      } else {\n        var targetIsItem = isItem(options.items, event.target);\n\n        if (!targetIsItem && currentElement) {\n          // If target is not a composite item, it may be the composite\n          // element itself (isSelfTarget) or a tabbable element inside the\n          // composite widget. This may be triggered by clicking outside the\n          // composite widget or by tabbing out of it. In either cases we\n          // want to fire a blur event on the current item.\n          fireBlurEvent(currentElement, event);\n        }\n      }\n    }, [options.unstable_virtual, options.items, currentItem]);\n    var onKeyDown = useCallback(function (event) {\n      var _onKeyDownRef$current, _options$groups;\n\n      (_onKeyDownRef$current = onKeyDownRef.current) === null || _onKeyDownRef$current === void 0 ? void 0 : _onKeyDownRef$current.call(onKeyDownRef, event);\n      if (event.defaultPrevented) return;\n      if (options.currentId !== null) return;\n      if (!isSelfTarget(event)) return;\n      var isVertical = options.orientation !== \"horizontal\";\n      var isHorizontal = options.orientation !== \"vertical\";\n      var isGrid = !!((_options$groups = options.groups) === null || _options$groups === void 0 ? void 0 : _options$groups.length);\n\n      var up = function up() {\n        if (isGrid) {\n          var item = findFirstEnabledItemInTheLastRow(options.items);\n\n          if (item === null || item === void 0 ? void 0 : item.id) {\n            var _options$move;\n\n            (_options$move = options.move) === null || _options$move === void 0 ? void 0 : _options$move.call(options, item.id);\n          }\n        } else {\n          var _options$last;\n\n          (_options$last = options.last) === null || _options$last === void 0 ? void 0 : _options$last.call(options);\n        }\n      };\n\n      var keyMap = {\n        ArrowUp: (isGrid || isVertical) && up,\n        ArrowRight: (isGrid || isHorizontal) && options.first,\n        ArrowDown: (isGrid || isVertical) && options.first,\n        ArrowLeft: (isGrid || isHorizontal) && options.last,\n        Home: options.first,\n        End: options.last,\n        PageUp: options.first,\n        PageDown: options.last\n      };\n      var action = keyMap[event.key];\n\n      if (action) {\n        event.preventDefault();\n        action();\n      }\n    }, [options.currentId, options.orientation, options.groups, options.items, options.move, options.last, options.first]);\n    return _objectSpread2({\n      ref: useForkRef(ref, htmlRef),\n      id: options.baseId,\n      onFocus: onFocus,\n      onFocusCapture: onFocusCapture,\n      onBlurCapture: onBlurCapture,\n      onKeyDownCapture: onKeyDownCapture,\n      onKeyDown: onKeyDown,\n      onKeyUpCapture: onKeyUpCapture,\n      \"aria-activedescendant\": options.unstable_virtual ? (currentItem === null || currentItem === void 0 ? void 0 : currentItem.id) || undefined : undefined\n    }, htmlProps);\n  },\n  useComposeProps: function useComposeProps(options, htmlProps) {\n    htmlProps = useRole(options, htmlProps, true);\n    var tabbableHTMLProps = useTabbable(options, htmlProps, true);\n\n    if (options.unstable_virtual || options.currentId === null) {\n      // Composite will only be tabbable by default if the focus is managed\n      // using aria-activedescendant, which requires DOM focus on the container\n      // element (the composite)\n      return _objectSpread2({\n        tabIndex: 0\n      }, tabbableHTMLProps);\n    }\n\n    return _objectSpread2(_objectSpread2({}, htmlProps), {}, {\n      ref: tabbableHTMLProps.ref\n    });\n  }\n});\nvar Composite = createComponent({\n  as: \"div\",\n  useHook: useComposite,\n  useCreateElement: function useCreateElement$1(type, props, children) {\n    process.env.NODE_ENV !== \"production\" ? useWarning(!props[\"aria-label\"] && !props[\"aria-labelledby\"], \"You should provide either `aria-label` or `aria-labelledby` props.\", \"See https://reakit.io/docs/composite\") : void 0;\n    return useCreateElement(type, props, children);\n  }\n});\nexport { Composite, useComposite };","map":{"version":3,"sources":["/Users/davimello/Creative Cloud Files/Davi/code/portfolio-react/node_modules/reakit/es/Composite/Composite.js"],"names":["a","_objectSpread2","_","_objectWithoutPropertiesLoose","createComponent","createHook","useRef","useEffect","useCallback","useReducer","useForkRef","warning","useWarning","useLiveRef","isSelfTarget","canUseDOM","useRole","useTabbable","useCreateElement","getDocument","fireBlurEvent","fireKeyboardEvent","getNextActiveElementOnBlur","f","flatten","r","reverse","g","groupItems","getCurrentId","findFirstEnabledItem","findEnabledItemById","C","COMPOSITE_KEYS","u","userFocus","isIE11","window","canProxyKeyboardEvent","event","metaKey","key","useKeyboardEventProxy","virtual","currentItem","htmlEventHandler","eventHandlerRef","_eventHandlerRef$curr","current","call","defaultPrevented","currentElement","ref","type","preventDefault","currentTarget","contains","stopPropagation","useActiveElementRef","elementRef","activeElementRef","document","onFocus","target","addEventListener","removeEventListener","findFirstEnabledItemInTheLastRow","items","isItem","element","some","item","useScheduleUserFocus","currentItemRef","_React$useReducer","n","scheduled","schedule","_currentItemRef$curre","useComposite","name","compose","keys","useOptions","options","currentId","useProps","_ref","htmlRef","htmlOnFocusCapture","onFocusCapture","htmlOnFocus","htmlOnBlurCapture","onBlurCapture","htmlOnKeyDown","onKeyDown","htmlOnKeyDownCapture","onKeyDownCapture","htmlOnKeyUpCapture","onKeyUpCapture","htmlProps","previousElementRef","onFocusCaptureRef","onFocusRef","onBlurCaptureRef","onKeyDownRef","scheduleUserFocus","undefined","unstable_moves","process","env","NODE_ENV","focus","unstable_virtual","_onFocusCaptureRef$cu","previousActiveElement","relatedTarget","previousActiveElementWasItem","_onFocusRef$current","_options$setCurrentId","setCurrentId","_onBlurCaptureRef$cur","nextActiveElement","nextActiveElementIsItem","targetIsItem","_onKeyDownRef$current","_options$groups","isVertical","orientation","isHorizontal","isGrid","groups","length","up","id","_options$move","move","_options$last","last","keyMap","ArrowUp","ArrowRight","first","ArrowDown","ArrowLeft","Home","End","PageUp","PageDown","action","baseId","useComposeProps","tabbableHTMLProps","tabIndex","Composite","as","useHook","useCreateElement$1","props","children"],"mappings":"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","sourcesContent":["import { a as _objectSpread2, _ as _objectWithoutPropertiesLoose } from '../_rollupPluginBabelHelpers-1f0bf8c2.js';\nimport { createComponent } from 'reakit-system/createComponent';\nimport { createHook } from 'reakit-system/createHook';\nimport 'reakit-utils/shallowEqual';\nimport { useRef, useEffect, useCallback, useReducer } from 'react';\nimport { useForkRef } from 'reakit-utils/useForkRef';\nimport 'reakit-utils/isButton';\nimport { warning, useWarning } from 'reakit-warning';\nimport { useLiveRef } from 'reakit-utils/useLiveRef';\nimport { isSelfTarget } from 'reakit-utils/isSelfTarget';\nimport 'reakit-utils/useIsomorphicEffect';\nimport 'reakit-utils/hasFocusWithin';\nimport 'reakit-utils/isPortalEvent';\nimport 'reakit-utils/getActiveElement';\nimport { canUseDOM } from 'reakit-utils/canUseDOM';\nimport 'reakit-utils/tabbable';\nimport { useRole } from '../Role/Role.js';\nimport { useTabbable } from '../Tabbable/Tabbable.js';\nimport { useCreateElement } from 'reakit-system/useCreateElement';\nimport { getDocument } from 'reakit-utils/getDocument';\nimport { fireBlurEvent } from 'reakit-utils/fireBlurEvent';\nimport { fireKeyboardEvent } from 'reakit-utils/fireKeyboardEvent';\nimport { getNextActiveElementOnBlur } from 'reakit-utils/getNextActiveElementOnBlur';\nimport { f as flatten, r as reverse, g as groupItems } from '../reverse-30eaa122.js';\nimport { g as getCurrentId, f as findFirstEnabledItem } from '../getCurrentId-5aa9849e.js';\nimport { f as findEnabledItemById } from '../findEnabledItemById-8ddca752.js';\nimport { C as COMPOSITE_KEYS } from '../__keys-6742f591.js';\nimport { u as userFocus } from '../userFocus-e16425e3.js';\n\nvar isIE11 = canUseDOM && \"msCrypto\" in window;\n\nfunction canProxyKeyboardEvent(event) {\n  if (!isSelfTarget(event)) return false;\n  if (event.metaKey) return false;\n  if (event.key === \"Tab\") return false;\n  return true;\n}\n\nfunction useKeyboardEventProxy(virtual, currentItem, htmlEventHandler) {\n  var eventHandlerRef = useLiveRef(htmlEventHandler);\n  return useCallback(function (event) {\n    var _eventHandlerRef$curr;\n\n    (_eventHandlerRef$curr = eventHandlerRef.current) === null || _eventHandlerRef$curr === void 0 ? void 0 : _eventHandlerRef$curr.call(eventHandlerRef, event);\n    if (event.defaultPrevented) return;\n\n    if (virtual && canProxyKeyboardEvent(event)) {\n      var currentElement = currentItem === null || currentItem === void 0 ? void 0 : currentItem.ref.current;\n\n      if (currentElement) {\n        if (!fireKeyboardEvent(currentElement, event.type, event)) {\n          event.preventDefault();\n        } // The event will be triggered on the composite item and then\n        // propagated up to this composite element again, so we can pretend\n        // that it wasn't called on this component in the first place.\n\n\n        if (event.currentTarget.contains(currentElement)) {\n          event.stopPropagation();\n        }\n      }\n    }\n  }, [virtual, currentItem]);\n} // istanbul ignore next\n\n\nfunction useActiveElementRef(elementRef) {\n  var activeElementRef = useRef(null);\n  useEffect(function () {\n    var document = getDocument(elementRef.current);\n\n    var onFocus = function onFocus(event) {\n      var target = event.target;\n      activeElementRef.current = target;\n    };\n\n    document.addEventListener(\"focus\", onFocus, true);\n    return function () {\n      document.removeEventListener(\"focus\", onFocus, true);\n    };\n  }, []);\n  return activeElementRef;\n}\n\nfunction findFirstEnabledItemInTheLastRow(items) {\n  return findFirstEnabledItem(flatten(reverse(groupItems(items))));\n}\n\nfunction isItem(items, element) {\n  return items === null || items === void 0 ? void 0 : items.some(function (item) {\n    return !!element && item.ref.current === element;\n  });\n}\n\nfunction useScheduleUserFocus(currentItem) {\n  var currentItemRef = useLiveRef(currentItem);\n\n  var _React$useReducer = useReducer(function (n) {\n    return n + 1;\n  }, 0),\n      scheduled = _React$useReducer[0],\n      schedule = _React$useReducer[1];\n\n  useEffect(function () {\n    var _currentItemRef$curre;\n\n    var currentElement = (_currentItemRef$curre = currentItemRef.current) === null || _currentItemRef$curre === void 0 ? void 0 : _currentItemRef$curre.ref.current;\n\n    if (scheduled && currentElement) {\n      userFocus(currentElement);\n    }\n  }, [scheduled]);\n  return schedule;\n}\n\nvar useComposite = createHook({\n  name: \"Composite\",\n  compose: [useTabbable],\n  keys: COMPOSITE_KEYS,\n  useOptions: function useOptions(options) {\n    return _objectSpread2(_objectSpread2({}, options), {}, {\n      currentId: getCurrentId(options)\n    });\n  },\n  useProps: function useProps(options, _ref) {\n    var htmlRef = _ref.ref,\n        htmlOnFocusCapture = _ref.onFocusCapture,\n        htmlOnFocus = _ref.onFocus,\n        htmlOnBlurCapture = _ref.onBlurCapture,\n        htmlOnKeyDown = _ref.onKeyDown,\n        htmlOnKeyDownCapture = _ref.onKeyDownCapture,\n        htmlOnKeyUpCapture = _ref.onKeyUpCapture,\n        htmlProps = _objectWithoutPropertiesLoose(_ref, [\"ref\", \"onFocusCapture\", \"onFocus\", \"onBlurCapture\", \"onKeyDown\", \"onKeyDownCapture\", \"onKeyUpCapture\"]);\n\n    var ref = useRef(null);\n    var currentItem = findEnabledItemById(options.items, options.currentId);\n    var previousElementRef = useRef(null);\n    var onFocusCaptureRef = useLiveRef(htmlOnFocusCapture);\n    var onFocusRef = useLiveRef(htmlOnFocus);\n    var onBlurCaptureRef = useLiveRef(htmlOnBlurCapture);\n    var onKeyDownRef = useLiveRef(htmlOnKeyDown);\n    var scheduleUserFocus = useScheduleUserFocus(currentItem); // IE 11 doesn't support event.relatedTarget, so we use the active element\n    // ref instead.\n\n    var activeElementRef = isIE11 ? useActiveElementRef(ref) : undefined;\n    useEffect(function () {\n      var element = ref.current;\n\n      if (options.unstable_moves && !currentItem) {\n        process.env.NODE_ENV !== \"production\" ? warning(!element, \"Can't focus composite component because `ref` wasn't passed to component.\", \"See https://reakit.io/docs/composite\") : void 0; // If composite.move(null) has been called, the composite container\n        // will receive focus.\n\n        element === null || element === void 0 ? void 0 : element.focus();\n      }\n    }, [options.unstable_moves, currentItem]);\n    var onKeyDownCapture = useKeyboardEventProxy(options.unstable_virtual, currentItem, htmlOnKeyDownCapture);\n    var onKeyUpCapture = useKeyboardEventProxy(options.unstable_virtual, currentItem, htmlOnKeyUpCapture);\n    var onFocusCapture = useCallback(function (event) {\n      var _onFocusCaptureRef$cu;\n\n      (_onFocusCaptureRef$cu = onFocusCaptureRef.current) === null || _onFocusCaptureRef$cu === void 0 ? void 0 : _onFocusCaptureRef$cu.call(onFocusCaptureRef, event);\n      if (event.defaultPrevented) return;\n      if (!options.unstable_virtual) return; // IE11 doesn't support event.relatedTarget, so we use the active\n      // element ref instead.\n\n      var previousActiveElement = (activeElementRef === null || activeElementRef === void 0 ? void 0 : activeElementRef.current) || event.relatedTarget;\n      var previousActiveElementWasItem = isItem(options.items, previousActiveElement);\n\n      if (isSelfTarget(event) && previousActiveElementWasItem) {\n        // Composite has been focused as a result of an item receiving focus.\n        // The composite item will move focus back to the composite\n        // container. In this case, we don't want to propagate this\n        // additional event nor call the onFocus handler passed to\n        // <Composite onFocus={...} />.\n        event.stopPropagation();\n      }\n    }, [options.unstable_virtual, options.items]);\n    var onFocus = useCallback(function (event) {\n      var _onFocusRef$current;\n\n      (_onFocusRef$current = onFocusRef.current) === null || _onFocusRef$current === void 0 ? void 0 : _onFocusRef$current.call(onFocusRef, event);\n      if (event.defaultPrevented) return;\n\n      if (options.unstable_virtual) {\n        if (isSelfTarget(event)) {\n          // This means that the composite element has been focused while the\n          // composite item has not. For example, by clicking on the\n          // composite element without touching any item, or by tabbing into\n          // the composite element. In this case, we want to trigger focus on\n          // the item, just like it would happen with roving tabindex.\n          // When it receives focus, the composite item will put focus back\n          // on the composite element, in which case hasItemWithFocus will be\n          // true.\n          scheduleUserFocus();\n        }\n      } else if (isSelfTarget(event)) {\n        var _options$setCurrentId;\n\n        // When the roving tabindex composite gets intentionally focused (for\n        // example, by clicking directly on it, and not on an item), we make\n        // sure to set the current id to null (which means the composite\n        // itself is focused).\n        (_options$setCurrentId = options.setCurrentId) === null || _options$setCurrentId === void 0 ? void 0 : _options$setCurrentId.call(options, null);\n      }\n    }, [options.unstable_virtual, options.setCurrentId]);\n    var onBlurCapture = useCallback(function (event) {\n      var _onBlurCaptureRef$cur;\n\n      (_onBlurCaptureRef$cur = onBlurCaptureRef.current) === null || _onBlurCaptureRef$cur === void 0 ? void 0 : _onBlurCaptureRef$cur.call(onBlurCaptureRef, event);\n      if (event.defaultPrevented) return;\n      if (!options.unstable_virtual) return; // When virtual is set to true, we move focus from the composite\n      // container (this component) to the composite item that is being\n      // selected. Then we move focus back to the composite container. This\n      // is so we can provide the same API as the roving tabindex method,\n      // which means people can attach onFocus/onBlur handlers on the\n      // CompositeItem component regardless of whether it's virtual or not.\n      // This sequence of blurring and focusing items and composite may be\n      // confusing, so we ignore intermediate focus and blurs by stopping its\n      // propagation and not calling the passed onBlur handler (htmlOnBlur).\n\n      var currentElement = (currentItem === null || currentItem === void 0 ? void 0 : currentItem.ref.current) || null;\n      var nextActiveElement = getNextActiveElementOnBlur(event);\n      var nextActiveElementIsItem = isItem(options.items, nextActiveElement);\n\n      if (isSelfTarget(event) && nextActiveElementIsItem) {\n        // This is an intermediate blur event: blurring the composite\n        // container to focus an item (nextActiveElement).\n        if (nextActiveElement === currentElement) {\n          // The next active element will be the same as the current item in\n          // the state in two scenarios:\n          //   - Moving focus with keyboard: the state is updated before the\n          // blur event is triggered, so here the current item is already\n          // pointing to the next active element.\n          //   - Clicking on the current active item with a pointer: this\n          // will trigger blur on the composite element and then the next\n          // active element will be the same as the current item. Clicking on\n          // an item other than the current one doesn't end up here as the\n          // currentItem state will be updated only after it.\n          if (previousElementRef.current && previousElementRef.current !== nextActiveElement) {\n            // If there's a previous active item and it's not a click action,\n            // then we fire a blur event on it so it will work just like if\n            // it had DOM focus before (like when using roving tabindex).\n            fireBlurEvent(previousElementRef.current, event);\n          }\n\n          previousElementRef.current = currentElement;\n        } else if (currentElement) {\n          // This will be true when the next active element is not the\n          // current element, but there's a current item. This will only\n          // happen when clicking with a pointer on a different item, when\n          // there's already an item selected, in which case currentElement\n          // is the item that is getting blurred, and nextActiveElement is\n          // the item that is being clicked.\n          fireBlurEvent(currentElement, event);\n          previousElementRef.current = nextActiveElement;\n        } // We want to ignore intermediate blur events, so we stop its\n        // propagation and return early so onFocus will not be called.\n\n\n        event.stopPropagation();\n      } else {\n        var targetIsItem = isItem(options.items, event.target);\n\n        if (!targetIsItem && currentElement) {\n          // If target is not a composite item, it may be the composite\n          // element itself (isSelfTarget) or a tabbable element inside the\n          // composite widget. This may be triggered by clicking outside the\n          // composite widget or by tabbing out of it. In either cases we\n          // want to fire a blur event on the current item.\n          fireBlurEvent(currentElement, event);\n        }\n      }\n    }, [options.unstable_virtual, options.items, currentItem]);\n    var onKeyDown = useCallback(function (event) {\n      var _onKeyDownRef$current, _options$groups;\n\n      (_onKeyDownRef$current = onKeyDownRef.current) === null || _onKeyDownRef$current === void 0 ? void 0 : _onKeyDownRef$current.call(onKeyDownRef, event);\n      if (event.defaultPrevented) return;\n      if (options.currentId !== null) return;\n      if (!isSelfTarget(event)) return;\n      var isVertical = options.orientation !== \"horizontal\";\n      var isHorizontal = options.orientation !== \"vertical\";\n      var isGrid = !!((_options$groups = options.groups) === null || _options$groups === void 0 ? void 0 : _options$groups.length);\n\n      var up = function up() {\n        if (isGrid) {\n          var item = findFirstEnabledItemInTheLastRow(options.items);\n\n          if (item === null || item === void 0 ? void 0 : item.id) {\n            var _options$move;\n\n            (_options$move = options.move) === null || _options$move === void 0 ? void 0 : _options$move.call(options, item.id);\n          }\n        } else {\n          var _options$last;\n\n          (_options$last = options.last) === null || _options$last === void 0 ? void 0 : _options$last.call(options);\n        }\n      };\n\n      var keyMap = {\n        ArrowUp: (isGrid || isVertical) && up,\n        ArrowRight: (isGrid || isHorizontal) && options.first,\n        ArrowDown: (isGrid || isVertical) && options.first,\n        ArrowLeft: (isGrid || isHorizontal) && options.last,\n        Home: options.first,\n        End: options.last,\n        PageUp: options.first,\n        PageDown: options.last\n      };\n      var action = keyMap[event.key];\n\n      if (action) {\n        event.preventDefault();\n        action();\n      }\n    }, [options.currentId, options.orientation, options.groups, options.items, options.move, options.last, options.first]);\n    return _objectSpread2({\n      ref: useForkRef(ref, htmlRef),\n      id: options.baseId,\n      onFocus: onFocus,\n      onFocusCapture: onFocusCapture,\n      onBlurCapture: onBlurCapture,\n      onKeyDownCapture: onKeyDownCapture,\n      onKeyDown: onKeyDown,\n      onKeyUpCapture: onKeyUpCapture,\n      \"aria-activedescendant\": options.unstable_virtual ? (currentItem === null || currentItem === void 0 ? void 0 : currentItem.id) || undefined : undefined\n    }, htmlProps);\n  },\n  useComposeProps: function useComposeProps(options, htmlProps) {\n    htmlProps = useRole(options, htmlProps, true);\n    var tabbableHTMLProps = useTabbable(options, htmlProps, true);\n\n    if (options.unstable_virtual || options.currentId === null) {\n      // Composite will only be tabbable by default if the focus is managed\n      // using aria-activedescendant, which requires DOM focus on the container\n      // element (the composite)\n      return _objectSpread2({\n        tabIndex: 0\n      }, tabbableHTMLProps);\n    }\n\n    return _objectSpread2(_objectSpread2({}, htmlProps), {}, {\n      ref: tabbableHTMLProps.ref\n    });\n  }\n});\nvar Composite = createComponent({\n  as: \"div\",\n  useHook: useComposite,\n  useCreateElement: function useCreateElement$1(type, props, children) {\n    process.env.NODE_ENV !== \"production\" ? useWarning(!props[\"aria-label\"] && !props[\"aria-labelledby\"], \"You should provide either `aria-label` or `aria-labelledby` props.\", \"See https://reakit.io/docs/composite\") : void 0;\n    return useCreateElement(type, props, children);\n  }\n});\n\nexport { Composite, useComposite };\n"]},"metadata":{},"sourceType":"module"}